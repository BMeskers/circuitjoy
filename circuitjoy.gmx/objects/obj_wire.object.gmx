<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.wirePickup = true;
wireplaced = false;
from = 0;
to = 0;
initPath = false;
hover = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//reset all changed values
if (from != 0){
    from.outputWire = 0;
}
if (to != 0){
    if (to.input1Wire == self){
        to.input1Wire = 0;
    }else {
        to.input2Wire = 0;
    }
}
global.wirePickup = false;

//remove all weights in the grid
if (wireplaced){
    for (i = 0; i &lt; ds_list_size(drawPath); i++){
            wID = ds_list_find_value(drawPath, i);
            wX = wID mod grid.gridX;
            wY = wID div grid.gridX;
            gridIndex = grid.grid[wX, wY];
            
            gridIndex[gridWeight[wID]] = 0;
            //remove entire array if it is now empty.
            for (k = 0; k &lt; array_length_1d(gridIndex); k++){
                if (gridIndex[k] != 0){
                    break;
                }
            }
            if (k == array_length_1d(gridIndex)){
                gridIndex = 0;
            }
            grid.grid[wX, wY] = gridIndex;
        }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!initPath){
    initPath = true;
    
    //get starting position
    if (to != 0){
        fromX = to.x - to.sprite_width - 1;
        fromY = to.y;
        if (to.object_index == obj_input){
            instance_destroy();
        }
    }else {
        fromX = from.x + from.sprite_width;
        fromY = from.y;
        if (from.object_index == obj_output){
            instance_destroy();
        }
    }
    grid = instance_find(obj_puzzleGrid, 0)
    startX = round((fromX - grid.x) / grid.gridWidth);
    startY = round((fromY - grid.y) / grid.gridHeight);
    //check if inside bounds
    if (startX &lt; 0 or startX &gt; grid.gridX - 1 or startY &lt; 0 or startY &gt; grid.gridY - 1){
        instance_destroy();
    }

    //initialize checking grid and path lists
    for (i = 0; i &lt; grid.gridX * grid.gridY; i += 1){
        gridChecked[i] = false;
        path[i] = ds_list_create();
    }
    
    for (j = 0; j &lt; grid.gridY; j++){
        for (i = 0; i &lt; grid.gridX; i++){
            show_debug_message("(" + string(i) + "," + string(j) + ")"); 
            gridIndex = grid.grid[i,j];
            gID = i + (grid.gridX * j);
            //show_debug_message(is_ptr(gridIndex));
            //show_debug_message(is_ptr(grid.grid[i,j]));
            show_debug_message(grid.grid[i,j]);
            if (is_real(gridIndex) and gridIndex == 0){
            gridWeight[gID] = 0;
            }else if (is_array(gridIndex)){
                gridWeight[gID] = noone;
                for (k = 0; k &lt; array_length_1d(gridIndex); k++){
                    if (gridIndex[k] == 0){
                        gridWeight[gID] = k;
                        show_debug_message("found: " + string(k) + " at: " + string(gID) + " (" + string(i) + "," + string(j) + ")");
                        break;
                    }
                    show_debug_message(string(gridWeight[gID]));
                }
            }else {
                gridWeight[gID] = noone;
            }
        }
    }
    
    //use a breath first search to find all possible paths.
    toCheck = ds_queue_create();
    fromID = startX + grid.gridX * startY;
    ds_list_add(path[fromID], fromID);
    gridChecked[fromID] = true;
    ds_queue_enqueue(toCheck, fromID);
    while (ds_queue_size(toCheck) &gt; 0){
        //Get the current element
        currentID = ds_queue_dequeue(toCheck);
        currentX = currentID mod grid.gridX;
        currentY  = currentID div grid.gridX;
        
        //loop over all neighbours
        for (i = 0; i &lt; 2*pi; i += pi/2){
            xMod = currentX + cos(i);
            yMod = currentY + sin(i);
            nID = xMod + grid.gridX * yMod;
            if (xMod &gt;= 0 and xMod &lt; grid.gridX and yMod &gt;= 0 and yMod &lt; grid.gridY){
                gridIndex = grid.grid[xMod, yMod];
                if (gridWeight[nID] != -4 and gridChecked[nID] == false){
                
                    for (j = 0; j &lt; ds_list_size(path[currentID]); j++){
                        ds_list_add(path[nID], ds_list_find_value(path[currentID], j));
                    }
                    ds_list_add(path[nID], nID);
                    ds_queue_enqueue(toCheck, nID);
                    gridChecked[nID] = true;
                }
                
            }
            
        }
    }
    ds_queue_destroy(toCheck);
    
    //set initial path
    drawPath = ds_list_create();
    ds_list_add(drawPath, fromID)
    destX = startX;
    destY = startY;
}

if (!wireplaced){
        //get the current path to the destination
        mouseGridX = floor((mouse_x - grid.x) / grid.gridWidth);
        mouseGridY = floor((mouse_y - grid.y) / grid.gridHeight);
        
        if (mouseGridX &gt;= 0 and mouseGridX &lt; grid.gridX and mouseGridY &gt;= 0 and mouseGridY &lt; grid.gridY){
            destX = mouseGridX;
            destY = mouseGridY;
        }
    
    destID = destX + grid.gridX * destY;
    placeComponent = instance_position(mouse_x, mouse_y, obj_component);
    
    destFound = false;
    if (placeComponent != noone){
            //get components grid position
            compX = (placeComponent.x - grid.x) / grid.gridWidth;
            destY = (placeComponent.y - grid.y) / grid.gridHeight;
            
            //check side of component
            //right side
            if (mouse_x &gt; placeComponent.x + placeComponent.sprite_width / 2){
                if (from = 0 and placeComponent != to and compX &lt; grid.gridX - 1){
                    destX = compX + 1;
                    //show_debug_message(string(destX));
                    destFound = true;
                }
            //left side
            }else if(compX &gt; 0){
                if (to = 0 and placeComponent != from){
                    //check if top side
                    if (mouse_y &lt; placeComponent.y + placeComponent.sprite_height / 2 || placeComponent.monoInput){
                        if (placeComponent.input1Wire = 0){
                            destX = compX - 1;
                            destFound = true;
                        }
                    //bottom side
                    }else{
                        if (placeComponent.input2Wire = 0){
                            destX = compX - 1;
                            destFound = true;
                        }
                    }
                }
            }
            //check if inside bounds
            if (destX &gt;= 0 and destX &lt; grid.gridX and destY &gt;= 0 and destY &lt; grid.gridY){
                destID = destX + grid.gridX * destY;
            }

        }
        
        //show_debug_message(string(ds_list_find_value(path[destID], ds_list_size(path[destID]) - 1)));
        if (ds_list_size(path[destID]) &gt; 0){
            if (ds_list_size(path[destID]) &gt; 1 || (fromID == destID)){
                drawPath = path[destID];
            }
        }
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initPath){
    if (global.wirePickup and !wireplaced){
        if (placeComponent != noone){
            
            //check on which side this component is pressed
            //right side
            if (mouse_x &gt; placeComponent.x + placeComponent.sprite_width / 2){
                if (from = 0 and placeComponent != to and compX &lt; grid.gridX - 1){
                    from = placeComponent;
                    global.wirePickup = false;
                    wireplaced = true;
                    //destX = compX + 1;
                    
                    //reverse the drawing path
                    tempPath = ds_list_create();
                    for (i = ds_list_size(drawPath) - 1; i &gt;= 0; i--){
                        ds_list_add(tempPath, ds_list_find_value(drawPath, i));
                    }
                    drawPath = tempPath;
                }
            //left side
            }else if(compX &gt; 0){
                if (to = 0 and placeComponent != from){
                    //check if top side
                    if (mouse_y &lt; placeComponent.y + placeComponent.sprite_height / 2 || placeComponent.monoInput){
                        if (placeComponent.input1Wire = 0){
                            to = placeComponent;
                            placeComponent.input1Wire = self;
                            global.wirePickup = false;
                            wireplaced = true;
                            //destX = compX - 1;
                        }
                    //bottom side
                    }else{
                        if (placeComponent.input2Wire = 0){
                            to = placeComponent;
                            placeComponent.input2Wire = self;
                            global.wirePickup = false;
                            wireplaced = true;
                            //destX = compX - 1;
                        }
                    }
                }
            }
        //abort placement if not properly placed
            if (!wireplaced){
                instance_destroy();
            }
        }else {
            instance_destroy();
        }
        
        
        if (wireplaced){
        //check if the chosen path is actually possible
        if (ds_list_size(drawPath) &gt; 1 || (fromID == destID)){
                //apply the correct gridWeights to the grid.
                for (i = 0; i &lt; ds_list_size(drawPath); i++){
                    wID = ds_list_find_value(drawPath, i);
                    wX = wID mod grid.gridX;
                    wY = wID div grid.gridX;
                    gridIndex = grid.grid[wX, wY];
                    if (!is_array(gridIndex)){
                        gridIndex[global.maxWireInCell - 1] = 0;
                    }
                    
                    show_debug_message("put: " + string(gridWeight[wID]) + " at: " + string(wID) + " (" + string(wX) + "," + string(wY) + ")");
                    gridIndex[gridWeight[wID]] = self;
                    grid.grid[wX, wY] = gridIndex;
                }
        }else {
            instance_destroy();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>wireWidth = 4;
if (ds_list_size(drawPath) &gt; 1 || (fromID == destID)){
    if (global.wirePickup and !wireplaced){
        //color = blue while being placed
        draw_set_colour($f3f57f);
        
        }else {
        if (from.output){
            //yellow if active
            draw_set_colour($22E2F0);
        }else {
            //green when not
            draw_set_colour($00AB34);
        }
    }
        
        if (from != 0){
            drawX = from.x + from.sprite_width;
            drawY = from.y + from.sprite_height / 2;
            reversed = false;
        }else {
            drawX = to.x;
            drawY = to.y + to.sprite_height / 4;
            if (self = to.input2Wire){
                drawY += to.sprite_height / 2;
            }
            if (to.monoInput){
                drawY += to.sprite_height / 4;
            }
            reversed = true;
             
        }
        
        xWeightOffset = grid.gridWidth / global.maxWireInCell;
        yWeightOffset = grid.gridHeight / global.maxWireInCell;
        
        tID = ds_list_find_value(drawPath, 0);
        twx = gridWeight[tID];
            tw = global.maxWireInCell / 2 - 1 - twx / 2;
            if (twx mod 2 == 1){
                tw += twx;
            }
            //tw = twx;
//        show_debug_message(string(tID) + " " + string(grid.gridX));
        tx = (tID mod grid.gridX) * grid.sprite_width + grid.x + (tw + 0.5) * xWeightOffset;
        ty = (tID div grid.gridX) * grid.sprite_height + grid.y + (tw + 0.5) * yWeightOffset;
        
        draw_line_width(drawX, drawY, tx, ty, wireWidth);
        for (i = 1; i &lt; ds_list_size(drawPath); i++){
            fx = tx
            fy = ty
            tID = ds_list_find_value(drawPath, i);
            twx = gridWeight[tID];
            tw = global.maxWireInCell / 2 - 1 - twx / 2;
            if (twx mod 2 == 1){
                tw += twx;
            }
            //tw = twx;
            tx = (tID mod grid.gridX) * grid.sprite_width + grid.x + (tw + 0.5) * xWeightOffset;
            ty = (tID div grid.gridX) * grid.sprite_height + grid.y + (tw + 0.5) * yWeightOffset;
            
            draw_line_width(fx, fy, tx, ty, wireWidth);
        }
        
        if (!(global.wirePickup and !wireplaced)){
            drawX = to.x;
            drawY = to.y + to.sprite_height / 4;
            if (self = to.input2Wire){
                drawY += to.sprite_height / 2;
            }
            if (to.monoInput){
                drawY += to.sprite_height / 4;
            }
            draw_line_width(tx, ty, drawX, drawY, wireWidth);
        }else if (placeComponent != noone){
            //get components grid position
            compX = (placeComponent.x - grid.x) / grid.gridWidth;
            destY = (placeComponent.y - grid.y) / grid.gridHeight;
                //check side of component
                //right side
                if (mouse_x &gt; placeComponent.x + placeComponent.sprite_width / 2){
                    show_debug_message(string(compX));
                    if (from = 0 and placeComponent != to and compX &lt; grid.gridX - 1 and compX &gt;= -1){
                        drawX = placeComponent.x;
                        drawY = placeComponent.y + placeComponent.sprite_height / 2;
                        draw_line_width(tx, ty, drawX, drawY, wireWidth);
                    }
                //left side
                }else if(compX &gt; 0){
                    if (to = 0 and placeComponent != from and compX &lt; grid.gridX + 1 and compX &gt;= 1){
                        //check if top side
                        if (mouse_y &lt; placeComponent.y + placeComponent.sprite_height / 2 || placeComponent.monoInput){
                            if (placeComponent.input1Wire = 0){
                                drawX = placeComponent.x;
                                drawY = placeComponent.y + placeComponent.sprite_height / 4;
                                if (placeComponent.monoInput){
                                    drawY += placeComponent.sprite_height / 4;
                                }
                                
                                draw_line_width(tx, ty, drawX, drawY, wireWidth);
                            }
                        //bottom side
                        }else{
                            if (placeComponent.input2Wire = 0){
                                drawX = placeComponent.x;
                                drawY = placeComponent.y + placeComponent.sprite_height / 4 * 3;
                                draw_line_width(tx, ty, drawX, drawY, wireWidth);
                            }
                        }
                    }
                }
            
        }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
